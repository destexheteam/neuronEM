import numpy as np
import scipy.signal
#import re, cell

from eap import field, cell, graph

def calc_grid(xrange, yrange, n_samp):
    xmin, xmax = xrange
    ymin, ymax = yrange

    try:
        n_x, n_y = n_samp
    except TypeError:
        n_x = n_y = n_samp

    x = np.linspace(xmin, xmax, n_x)
    y = np.linspace(ymin, ymax, n_y)

    XX, YY = np.meshgrid(x, y)

    return XX, YY


def calc_trapezio_B_seg(coords, pos0):
    # magnetic field of a finite cylinder of radius R  lenght l. It returns the field generated by each cylinder n the position pos. THE VALUE OF THE CURRENT IS NOT INCLUDED. Lenght of the array= number of cylinders.
    # calcolo del campo magnetico di ogni cilindretto di raggio e lunghezza finiti: ritorna array del campo generato da ogni cilindro nella posizione pos A MENO DEL VALORE DELLA CORRENTE( lunghezza array = numero cilindri) METODO INTEGRALE TRAPEZIO ##
    R = coords['diam'] / 2.  # lunghezza numero segmenti
    l = coords['L'] / 2.
    factor = 2.e-7  # mu0*2/4*pi [N*A-2]
    y0 = pos0[1]
    x0 = pos0[0]
    numdx = 100.
    dx = 2 * R / numdx
    all_b = []
    for i in range(len(R)):
        n = -R[i] + dx[i]
        b = 0.
        while (n <= R[i]):
            numA = np.sqrt(R[i] ** 2 - n ** 2) * (l[i] - y0[i])
            denA = (x0[i] - n) * np.sqrt((n - x0[i]) ** 2 + R[i] ** 2 - n ** 2 + (l[i] - y0[i]) ** 2)
            numB = np.sqrt(R[i] ** 2 - n ** 2) * (l[i] + y0[i])
            denB = (x0[i] - n) * np.sqrt((n - x0[i]) ** 2 + R[i] ** 2 - n ** 2 + (l[i] + y0[i]) ** 2)
            numAk = np.sqrt(abs(R[i] ** 2 - (n - dx[i]) ** 2)) * (l[i] - y0[i])
            denAk = (x0[i] - (n - dx[i])) * np.sqrt(
                ((n - dx[i]) - x0[i]) ** 2 + R[i] ** 2 - (n - dx[i]) ** 2 + (l[i] - y0[i]) ** 2)
            numBk = np.sqrt(abs(R[i] ** 2 - (n - dx[i]) ** 2)) * (l[i] + y0[i])
            denBk = (x0[i] - (n - dx[i])) * np.sqrt(
                ((n - dx[i]) - x0[i]) ** 2 + R[i] ** 2 - (n - dx[i]) ** 2 + (l[i] + y0[i]) ** 2)
            # print i, n, numA,numB,denA,denB,numAk,numBk,denAk,denBk
            f = factor * (np.arctan(numA / denA) + np.arctan(numB / denB))
            fk = factor * (np.arctan(numAk / denAk) + np.arctan(numBk / denBk))
            # if i == 1151:
            #    print i,f,fk,n,(((n-dx[i])-x0[i])**2+R[i]**2-(n-dx[i])**2+(l[i]-y0[i])**2),(n-dx[i])**2,(((n-dx[i])-x0[i])**2+R[i]**2+(l[i]-y0[i])**2)
            try:
                b += ((f + fk) * dx[i]) / 2.
                n += dx[i]
            except:
                n += dx[i]
                continue
                # print i, b
        all_b.append(b)
    return np.array(all_b)


def calc_B_finite_wire(coords, pos0):
    R = coords['diam'] / 2.  # lunghezza numero segmenti
    l = coords['L'] / 2.
    mu0 = 4 * np.pi * 1.e-7  # N/A^2

    y0 = pos0[1]
    x0 = pos0[0]
    all_BW = []
    for i in range(len(l)):
        BW = (mu0 * R[i] ** 2 / (4)) * (
            (l[i] - y0[i]) / (x0[i] * np.sqrt(x0[i] ** 2 + (y0[i] - l[i]) ** 2)) + (l[i] + y0[i]) / (
            x0[i] * np.sqrt(x0[i] ** 2 + (y0[i] + l[i]) ** 2)))


        all_BW.append(BW)

    return np.array(all_BW)


def calc_B_sum(pos, z, coords, I):
    # calculate B generated by all cylinders with current density I in the position pos.
    # calcolo di B generato da tutti cilindri con densita di corrente I nella posizione pos
    c = 1.e-5  # fattore conversione in Tesla
    # I=[mA/cm2] mu0= [N/A**2] integrale_Trapezio=[um] --> B=[1.e-5 T]
    x0, y0, ex, ey, ez = coords_change(coords, pos, z)
    pos0 = (x0, y0)
    B = calc_B_finite_wire(coords, pos0)

    # print len(positive_seg), len(negative_seg),len(positive_seg)+ len(negative_seg)
    # B = calc_int_B_seg(coords,pos0)
    Bsumx = []
    Bsumy = []
    Bsumz = []

    for i in range(len(I)):
        ssx = np.sum(c * B * I[i] * ex)
        ssy = np.sum(c * B * I[i] * ey)
        ssz = np.sum(c * B * I[i] * ez)

        Bsumx.append(ssx)
        Bsumy.append(ssy)
        Bsumz.append(ssz)
    return np.array(Bsumx), np.array(Bsumy), np.array(Bsumz)


def coords_change(coords, pos, z):
    x = pos[0]
    y = pos[1]
    z = z
    # centro del cilindro
    #axon = cell.select_sec(coords, "axon*")
    dendrite = cell.select_sec(coords, "dendrite*")
    selected = np.hstack([dendrite])

    #import pdb; pdb.set_trace()
    selected = np.arange(0,len(coords),1) # cell.select_sec(coords, "*")
    #selected = np.asarray(selected, dtype=int)


    soma = cell.select_sec(coords, "soma*")
    #user5 = cell.select_sec(coords, "user5*")
    apical = cell.select_sec(coords, "apic*")
    nonselected = np.hstack([soma, apical]) #user5, apical])
    nonselected = np.asarray(nonselected, dtype=int)

    ex = np.empty(len(coords))
    ey = np.empty(len(coords))
    ez = np.empty(len(coords))
    xc = np.empty(len(coords))
    yc = np.empty(len(coords))
    zc = np.empty(len(coords))
    dn = np.empty(len(coords))
    nx = np.empty(len(coords))
    ny = np.empty(len(coords))
    nz = np.empty(len(coords))
    vx = np.empty(len(coords))
    vy = np.empty(len(coords))
    vz = np.empty(len(coords))
    norma = np.empty(len(coords))
    y0 = np.empty(len(coords))
    x0 = np.empty(len(coords))
    vvx = np.empty(len(coords))
    vvy = np.empty(len(coords))
    vvz = np.empty(len(coords))
    dv = np.empty(len(coords))

    xc[selected] = coords[selected]['x1'] + (coords[selected]['x0'] - coords[selected]['x1']) / 2.
    yc[selected] = coords[selected]['y1'] + (coords[selected]['y0'] - coords[selected]['y1']) / 2.
    zc[selected] = coords[selected]['z1'] + (coords[selected]['z0'] - coords[selected]['z1']) / 2.
    dn[selected] = np.sqrt((coords[selected]['x1'] - coords[selected]['x0']) ** 2 + (
    coords[selected]['y1'] - coords[selected]['y0']) ** 2 + (coords[selected]['z1'] - coords[selected]['z0']) ** 2)
    nx[selected] = (coords[selected]['x0'] - coords[selected]['x1']) / dn[selected]
    ny[selected] = (coords[selected]['y0'] - coords[selected]['y1']) / dn[selected]
    nz[selected] = (coords[selected]['z0'] - coords[selected]['z1']) / dn[selected]
    vx[selected] = (x - xc[selected])
    vy[selected] = (y - yc[selected])
    vz[selected] = (z - zc[selected])

    norma[selected] = vx[selected] ** 2 + vy[selected] ** 2 + vz[selected] ** 2

    y0[selected] = vx[selected] * nx[selected] + vy[selected] * ny[selected] + vz[selected] * nz[selected]

    x0[selected] = np.sqrt(norma[selected] - y0[selected] ** 2)
    vvx[selected] = ny[selected] * vz[selected] - nz[selected] * vy[selected]
    vvy[selected] = nz[selected] * vx[selected] - nx[selected] * vz[selected]
    vvz[selected] = nx[selected] * vy[selected] - ny[selected] * vx[selected]

    dv[selected] = np.sqrt(vvx[selected] ** 2 + vvy[selected] ** 2 + vvz[selected] ** 2)
    ex[selected] = vvx[selected] / dv[selected]
    ey[selected] = vvy[selected] / dv[selected]
    ez[selected] = vvz[selected] / dv[selected]

    ####################################################
    '''
    xc[nonselected] = coords[nonselected]['x0'] + (coords[nonselected]['x1'] - coords[nonselected]['x0']) / 2.
    yc[nonselected] = coords[nonselected]['y0'] + (coords[nonselected]['y1'] - coords[nonselected]['y0']) / 2.
    zc[nonselected] = coords[nonselected]['z0'] + (coords[nonselected]['z1'] - coords[nonselected]['z0']) / 2.

    # vettore normale al cilindro
    dn[nonselected] = np.sqrt((coords[nonselected]['x1'] - coords[nonselected]['x0']) ** 2 + (
    coords[nonselected]['y1'] - coords[nonselected]['y0']) ** 2 + (
                              coords[nonselected]['z1'] - coords[nonselected]['z0']) ** 2)
    # print dn
    nx[nonselected] = (coords[nonselected]['x1'] - coords[nonselected]['x0']) / dn[nonselected]
    ny[nonselected] = (coords[nonselected]['y1'] - coords[nonselected]['y0']) / dn[nonselected]
    nz[nonselected] = (coords[nonselected]['z1'] - coords[nonselected]['z0']) / dn[nonselected]

    vx[nonselected] = (x - xc[nonselected])
    vy[nonselected] = (y - yc[nonselected])
    vz[nonselected] = (z - zc[nonselected])

    norma[nonselected] = vx[nonselected] ** 2 + vy[nonselected] ** 2 + vz[nonselected] ** 2

    y0[nonselected] = vx[nonselected] * nx[nonselected] + vy[nonselected] * ny[nonselected] + vz[nonselected] * nz[
        nonselected]

    x0[nonselected] = np.sqrt(norma[nonselected] - y0[nonselected] ** 2)

    # vettore prodotto vettoriale n X v

    vvx[nonselected] = ny[nonselected] * vz[nonselected] - nz[nonselected] * vy[nonselected]
    vvy[nonselected] = nz[nonselected] * vx[nonselected] - nx[nonselected] * vz[nonselected]
    vvz[nonselected] = nx[nonselected] * vy[nonselected] - ny[nonselected] * vx[nonselected]

    dv[nonselected] = np.sqrt(vvx[nonselected] ** 2 + vvy[nonselected] ** 2 + vvz[nonselected] ** 2)

    ex[nonselected] = vvx[nonselected] / dv[nonselected]
    ey[nonselected] = vvy[nonselected] / dv[nonselected]
    ez[nonselected] = vvz[nonselected] / dv[nonselected]
    '''

    return x0, y0, ex, ey, ez


def estimate_B_on_grid(coords, I, XX, YY, z):
    """Estimate field on a grid.

    Arguments:

    * coord (structured array) -- coordinates of neuron segments (see
    estimate_lsa for details)
    * I (2d array, float) -- current densities in time and (neuronal) space
    * X (2d array, float) -- X coordinates of grid data 
    * Y (2d array, float) -- Y coordinates of grid data
    * z (scalar, float) - z coordinate 
    """
    if not XX.shape == YY.shape:
        raise TypeError, "XX and YY must have the same dimensions"

    ts, _ = I.shape
    xs, ys = XX.shape
    BBx = np.zeros((ts, xs, ys))
    BBy = np.zeros((ts, xs, ys))
    BBz = np.zeros((ts, xs, ys))
    for i in range(xs):
        for j in range(ys):
            Bx, By, Bz = calc_B_sum((XX[i, j], YY[i, j]), z, coords, I)
            BBx[:, i, j] = Bx
            BBy[:, i, j] = By
            BBz[:, i, j] = Bz
    return BBx, BBy, BBz


def rototraslation(coords, rotot):
    dx = rotot[0]
    dy = rotot[1]
    dz = rotot[2]
    theta = rotot[3]
    total_segs = 11659
    nchars = 20
    rtcoords = np.zeros(total_segs,
                        dtype=[("x0", np.float32),
                               ("y0", np.float32),
                               ("z0", np.float32),
                               ("x1", np.float32),
                               ("y1", np.float32),
                               ("z1", np.float32),
                               ("L", np.float32),
                               ("diam", np.float32),
                               ("name", "|S%d" % nchars)
                               ])

    # rototraslazione del vettore coordinate
    rtcoords['x0'] = coords['x0'] * (np.cos(theta)) + (np.sin(theta)) * coords['z0'] + dx
    rtcoords['y0'] = coords['y0'] + dy
    rtcoords['z0'] = coords['x0'] * (-np.sin(theta)) + (np.cos(theta)) * coords['z0'] + dz

    rtcoords['x1'] = coords['x1'] * (np.cos(theta)) + (np.sin(theta)) * coords['z1'] + dx
    rtcoords['y1'] = coords['y1'] + dy
    rtcoords['z1'] = coords['x1'] * (-np.sin(theta)) + (np.cos(theta)) * coords['z1'] + dz

    rtcoords['L'] = coords['L']
    rtcoords['diam'] = coords['diam']
    rtcoords['name'] = coords['name']

    return rtcoords


def calc_B_sum_multiple_neurons(coords, Isp, Ist, pos, z, rt_par, pas):
    # calculate the field due by multiple neurons.

    bx = 0.
    by = 0.
    bz = 0.
    rt_all = []
    num_neurons = 0
    for i in range(len(rt_par)):
        print 'I am at neuron', i
        dx = rt_par[i][0]
        dy = rt_par[i][1]
        dz = rt_par[i][2]
        theta = rt_par[i][3]
        rt = np.array([dx, dy, dz, theta])
        num_neurons += 1
        rtcoords = rototraslation(coords, rt)
        if num_neurons in pas:
            Bx, By, Bz = calc_B_sum(pos, z, rtcoords, Isp)
        else:
            Bx, By, Bz = calc_B_sum(pos, z, rtcoords, Ist)
        bx = bx + Bx
        by = by + By
        bz = bz + Bz

    return bx, by, bz


def estimate_B_multiple_neuron_on_grid(coords, Isp, Ist, XX, YY, z, rt_par, pas):
    """Estimate field on a grid.

    Arguments:

    * coord (structured array) -- coordinates of neuron segments (see
    estimate_lsa for details)
    * I (2d array, float) -- current densities in time and (neuronal) space
    * X (2d array, float) -- X coordinates of grid data 
    * Y (2d array, float) -- Y coordinates of grid data
    * z (scalar, float) - z coordinate 
    """
    if not XX.shape == YY.shape:
        raise TypeError, "XX and YY must have the same dimensions"

    ts, _ = Isp.shape
    xs, ys = XX.shape
    BBx = np.zeros((ts, xs, ys))
    BBy = np.zeros((ts, xs, ys))
    BBz = np.zeros((ts, xs, ys))
    for i in range(xs):
        for j in range(ys):
            print i, j
            Bx, By, Bz = calc_B_sum_multiple_neurons(coords, Isp, Ist, (XX[i, j], YY[i, j]), z, rt_par, pas)
            BBx[:, i, j] = Bx
            BBy[:, i, j] = By
            BBz[:, i, j] = Bz
    return BBx, BBy, BBz